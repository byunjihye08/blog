{"componentChunkName":"component---src-templates-post-template-jsx","path":"/design-pattern/di/","result":{"data":{"site":{"siteMetadata":{"title":"변지혜 블로그","subtitle":"행동하는 개발자","copyright":"© All rights reserved.","author":{"name":"변지혜","twitter":"#"},"disqusShortname":"regyu","url":"https://wisdom08.netlify.com/"}},"markdownRemark":{"id":"620cde9c-9876-5d16-a94a-ec66d967ae59","html":"<h1>객체를 사용하는 두가지 방법</h1>\n<ol>\n<li>\n<p>A객체가 B/C 객체를 직접 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class A {\n\tprivate B b = new B();\n\tprivate C c = new C();\n}</code></pre></div>\n<p>a는 갑 b,c는 을</p>\n<p>a가 b,c를 사용하기도 하지만 b,c에 의존 하기도 한다.</p>\n<p>객체 간의 의존 관계에서 직접 생성 하면 생성 부터 메모리 관리를 위한 소멸까지 해당 객체의 라이프 사이클을 개발자가 직접 관리 해주어야 됨으로 객체 간 강한 결합이다</p>\n</li>\n<li>\n<p>B/C 객체가 외부에 생성되어 A객체에 주입된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class A {\n \tprivate B b;\n\tprivate C c;\n\n\tpublic A (B b, C c) {\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n//or\n\tpublic void setb(B b){\n\t\tthis.b = b;\n\t}\n\n\tpublic void setC(C c){\n\t\tthis.c = c;\n\t}\n}</code></pre></div>\n<p>a가 을 bc를 가지고, 있는 곳이 갑</p>\n<p>a가  b,c기능이 필요하면 갑이 a에게 bc의 기능을 주입 시켜주는 구조이다.</p>\n<p>이미 누군가가  생성한 객체를 주입 받아 사용만 하면 됨으로 약한 결합이다.</p>\n<p>객체 지향에서 약한 결합, 느슨한 결합을 사용하면 개발자가 관리 할 것이 작아진다는 장점이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package di;\n\nimport java.util.Date;\n\npublic class UnderstandDI {\n    public static void main(String[] args) {\n        Date date = new Date();\n        System.out.println(date);\n    }\n\n    public static void getDate(Date d) {\n        Date date = d;\n        System.out.println(date);\n    }\n\n    public static void memberUser1() {\n//        강한 결합 : 직접 생성\n        Member m1 = new Member();\n//        억지스럽지만 Member 클래스의 생성자 메서드를 private 으로 변경하면 문제가 생긴다\n//        이와 반대로 약한 겷합은 안전하고 유연하게 대체 가능하다\n    }\n\n    public static void memberUser2(Member m) {\n//        약한 결합 : 생성된 것을 주입 받음 - 의존 주입 (Dependency Injection)\n        Member m2 = m;\n    }\n}\n\n//    Member를 사용한다.--&gt;Member의 기능에 의존한다 라는 의미\nclass Member {\n    String name;\n    String nickname;\n\n    public Member() {\n\n    }\n//    private Member() {\n//    }\n}</code></pre></div>\n</li>\n</ol>","fields":{"tagSlugs":["/tags/di/","/tags/design-pattern/"],"slug":"/design-pattern/di/"},"frontmatter":{"title":"DI (Dependency Injection)","tags":["DI","design pattern"],"date":"2020-01-01T05:06:35.750Z","description":"객체 읜존성과 객체지향에서의 결합 관계에 대해 간략하게 정리한 내용","path":"/design-pattern/di/","category":"design-pattern"},"tableOfContents":"<ul>\n<li><a href=\"/design-pattern/di/#%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%91%90%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95\">객체를 사용하는 두가지 방법</a></li>\n</ul>","headings":[{"value":"객체를 사용하는 두가지 방법","depth":1}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/design-pattern/di/"}}}