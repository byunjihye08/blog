{"componentChunkName":"component---src-templates-post-template-jsx","path":"/design-pattern/flyweight/","result":{"data":{"site":{"siteMetadata":{"title":"변지혜 블로그","subtitle":"행동하는 개발자","copyright":"© All rights reserved.","author":{"name":"변지혜","twitter":"#"},"disqusShortname":"regyu","url":"https://wisdom08.netlify.com/"}},"markdownRemark":{"id":"4380e7e6-b96f-514d-be9b-7fadbe0a9d7c","html":"<h1>플라이웨이트 패턴</h1>\n<blockquote>\n<p>플라이웨이트 패턴은 비용이 큰 자원을 공통으로 사용할 수 있도록 만드는 패턴이다. 1990년에 Paul Calder와 Mark Linton이 WYSIWYG 문서 편집기의 글자모양 정보를 효율적으로 다루기 위해 처음 도입되고 널리 연구되어 졌다.</p>\n</blockquote>\n<p>자원에 대한 비용은 크게 두가지로 나눠 볼 수 있다.</p>\n<ol>\n<li>\n<p>중복 생성될 가능성이 높은 경우.</p>\n<ul>\n<li>중복 생성될 가능성이 높다는 것은 동일한 자원이 자주 사용될 가능성이 매우 높다는 것을 의미한다. 이런 자원은 공통 자원 형태로 관리해 주는 편이 좋다.</li>\n</ul>\n</li>\n<li>\n<p>자원 생성 비용은 큰데 사용 빈도가 낮은 경우.</p>\n<ul>\n<li>이런 자원을 항상 미리 생성해 두는 것은 낭비이다. 따라서 요청이 있을 때에 생성해서 제공해주는 편이 좋다.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>이 두가지 목적을 위해서 플라이웨이트 패턴은 자원 생성과 제공을 책임진다.</p>\n<p>자원의 생성을 담당하는 Factory 역할과 관리 역할을 분리하는 것이 좋을 수 있으나, 일반적으로는 역할의 크기가 그리 크지 않아서 하나의 클래스가 담당하도록 구현한다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>많은 객체를 만들 때 성능을 향상시킬 수 있다.</li>\n<li>많은 객체를 만들 때 메모리를 줄일 수 있다.</li>\n<li>State pattern과 쉽게 결합될 수 있다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>특정 인스턴스의 공유 컴포넌트를 다르게 행동하게 하는 것이 불가능 하다.</li>\n<li>(개별 설정이 불가능 하다.)</li>\n</ul>\n<h2>예제 - Tree</h2>\n<p>Tree 클래스로 만들어지는 객체는 mesh, bark, leaves 등 객체를 직접 만들지 않고 미리 만들어진 TreeModel을 사용한다.</p>\n<p>static 변수로 선언된 객체를 하나 만들어 모든 Tree 객체의 내부에서 사용되는 TreeModel 에서 공유한다.</p>\n<ul>\n<li>\n<p>각각의 Tree 클래스에 직접 만드는 예시</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TreeFactory {\n    private static final TreeModel sharedTreeModel = new TreeModel();\n\n    static public Tree create(Position position, double height, double thickness) {\n        Tree tree = new Tree();\n        tree.setPosition(position);\n        tree.setHeight(height);\n        tree.setThickness(thickness);\n        tree.setTreeModel(sharedTreeModel);\n        \n        return tree;\n    }\n}\n\npublic class Tree {\n    Mesh mesh;\n    Texture bark;\n    Texture leaves;\n    Position position;\n    double height;\n    double thickness;\n    Color barkTint;\n    Color leafTint;\n}</code></pre></div>\n</li>\n<li>\n<p>Flyweight pattern 을 이용하여 공유할 객체를 분리 된 코드</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Tree {\n    TreeModel treeModel;\n    Position position;\n    double height;\n    double thickness;\n}\n\n// 공유할 객체를 감쌀 나무모델 클래스를 정의\npublic class TreeModel {\n    Mesh mesh;\n    Texture bark;\n    Texture leaves;\n\n    public TreeModel() {\n        this.mesh = new Mesh();\n        this.bark = new Texture(&quot;bark&quot;);\n        this.leaves = new Texture(&quot;leaves&quot;);\n    }\n}</code></pre></div>\n</li>\n</ul>\n<h2>Flyweight pattern 사용 예</h2>\n<ul>\n<li>\n<p>고전적인 사용 예</p>\n<ul>\n<li>워드 프로세서에서 문자들의 그래픽적 표현에 대한 자료구조</li>\n<li>문서에 입력된 모든 글자들에 대해서 글자(폰트) 정보를 가지고 있다면 메모리 낭비가 일어난다.</li>\n</ul>\n</li>\n<li>\n<p>JDK 예</p>\n<ul>\n<li>java.lang.String</li>\n<li>java.lang.Integer.valueOf(int)</li>\n<li>java.lang.###.valueOf( ) 형식</li>\n</ul>\n</li>\n</ul>\n<h3>java.lang.String의 예시</h3>\n<p>str1 과 str2는 각자 새로운 객체를 생성 하였기 때문에 서로 다른 객체 이지만 str3 과 str4는 같은 객체이다.(참조 되는 메모리가 같다. 중복 생성을 방지한다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestPattern {\n    public static void main(String[] args) {\n        String str1 = new String(&quot;홍길동&quot;);\n        String str2 = new String(&quot;홍길동&quot;);\n        String str3 = &quot;홍길동&quot;;\n        String str4 = &quot;홍길동&quot;;\n\n        System.out.println(&quot;Flyweight Pattern&quot;);\n    }\n}</code></pre></div>\n<h3>얕은 복사도 일종의 Flyweight 패턴이 적용되어 있다.</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestPattern {\n    public static void main(String[] args) {\n        MyData md1 = new MyData();\n        md1.xpos = 10;\n        md1.ypos = 11;\n        md1.name = &quot;홍길동&quot;;\n\n        MyData md2 = new MyData();\n        md2 = md1;\n\n        MyData md3 = new MyData();\n        md3.xpos = 20;\n        md3.ypos = 21;\n        md3.name = &quot;손오공&quot;;\n\n        md2.name = &quot;전우지&quot;;\n        md2.xpos = 5;\n    }\n}\n\nclass MyData {\n    int xpos;\n    int ypos;\n    String name;\n}</code></pre></div>\n<h3>Flyweight 패턴 구현하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Subject {\n    private String name;\n\n    public Subject(String name) {\n        this.name = name;\n    }\n}\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class FlyweightFactory {\n    private static Map&lt;String, Subject&gt; map = new HashMap&lt;&gt;();\n\n    public Subject getSubject(String key) {\n        Subject subject = map.get(key);\n        if (subject == null) {\n            subject = new Subject(key);\n            map.put(key, subject);\n\n            System.out.println(&quot;새로 생성&quot; + key);\n        } else {\n            System.out.println(&quot;재사용&quot; + key);\n        }\n\n        return subject;\n    }\n}</code></pre></div>\n<p> Test code 사용 예시</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestPattern {\n    public static void main(String[] args) {\n        FlyweightFactory flyweightFactory = new FlyweightFactory();\n        flyweightFactory.getSubject(&quot;a&quot;);\n        flyweightFactory.getSubject(&quot;a&quot;);\n        flyweightFactory.getSubject(&quot;b&quot;);\n        flyweightFactory.getSubject(&quot;b&quot;);\n    }\n}</code></pre></div>","fields":{"tagSlugs":["/tags/flyweight/","/tags/design-pattern/"],"slug":"/design-pattern/flyweight/"},"frontmatter":{"title":"Flyweight 패턴","tags":["Flyweight","design pattern"],"date":"2020-01-03T05:06:35.750Z","description":"플라이웨이트 패턴은 비용이 큰 자원을 공통으로 사용할 수 있도록 만드는 패턴이다. 1990년에 Paul Calder와 Mark Linton이 WYSIWYG 문서 편집기의 글자모양 정보를 효율적으로 다루기 위해 처음 도입되고 널리 연구되어 졌다.","path":"/design-pattern/flyweight/","category":"design-pattern"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/design-pattern/flyweight/#%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4\">플라이웨이트 패턴</a></p>\n<ul>\n<li><a href=\"/design-pattern/flyweight/#%EC%98%88%EC%A0%9C---tree\">예제 - Tree</a></li>\n<li>\n<p><a href=\"/design-pattern/flyweight/#flyweight-pattern-%EC%82%AC%EC%9A%A9-%EC%98%88\">Flyweight pattern 사용 예</a></p>\n<ul>\n<li><a href=\"/design-pattern/flyweight/#javalangstring%EC%9D%98-%EC%98%88%EC%8B%9C\">java.lang.String의 예시</a></li>\n<li><a href=\"/design-pattern/flyweight/#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EB%8F%84-%EC%9D%BC%EC%A2%85%EC%9D%98-flyweight-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%98%EC%96%B4-%EC%9E%88%EB%8B%A4\">얕은 복사도 일종의 Flyweight 패턴이 적용되어 있다.</a></li>\n<li><a href=\"/design-pattern/flyweight/#flyweight-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">Flyweight 패턴 구현하기</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","headings":[{"value":"플라이웨이트 패턴","depth":1},{"value":"예제 - Tree","depth":2},{"value":"Flyweight pattern 사용 예","depth":2},{"value":"java.lang.String의 예시","depth":3},{"value":"얕은 복사도 일종의 Flyweight 패턴이 적용되어 있다.","depth":3},{"value":"Flyweight 패턴 구현하기","depth":3}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/design-pattern/flyweight/"}}}