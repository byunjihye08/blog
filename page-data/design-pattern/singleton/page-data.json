{"componentChunkName":"component---src-templates-post-template-jsx","path":"/design-pattern/singleton/","result":{"data":{"site":{"siteMetadata":{"title":"변지혜 블로그","subtitle":"행동하는 개발자","copyright":"© All rights reserved.","author":{"name":"변지혜","twitter":"#"},"disqusShortname":"regyu","url":"https://wisdom08.netlify.com/"}},"markdownRemark":{"id":"78b84607-34b8-593f-a0cb-9f10ce2766bb","html":"<h1>싱글턴 패턴</h1>\n<p>객체가 너무 많아지면 컴퓨터 자원을 과도하게 사용하게 되고, 이는 프로그램 전체의 속도를 느리게 할 수 있다.</p>\n<p>→ 개발자는 객체의 최대 개수를 제한할 필요가 생긴다.</p>\n<p>싱글턴 패턴 : 최대 N개로 객체 생성을 제한하는 패턴</p>\n<p>→ 여기서 중요한 것은 생성되는 객체의 최대 개수를 제한하는 데 있어 객체의 생성을 요청하는 쪽에서는 일일이 신경쓰지 않아도 되도록 만들어주는 것이다.</p>\n<h2>사용 예</h2>\n<p>일반 자바 프로그래밍</p>\n<ul>\n<li>데이터베이스 컨넥션 풀</li>\n<li>로그 라이터</li>\n</ul>\n<p>게임 프로그래밍</p>\n<ul>\n<li>사운드 매니저</li>\n<li>스코어 매니저</li>\n</ul>\n<h3>객체 생성 개수 제한 하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Database {\n    private static Database singleton;\n    private String name;\n\n    public Database(String name) {\n        super();\n        this.name = name;\n    }\n\n    public static Database getInstance(String name) {\n        if (singleton == null) {\n            singleton = new Database(name);\n        }\n        return singleton;\n    }\n\n    public String getName() {\n        return name;\n    }\n}</code></pre></div>\n<p> Test code 사용 예시</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestPattern1 {\n\n    public static void main(String[] args) {\n        Database database;\n        database = Database.getInstance(&quot;첫 번째&quot;);\n        System.out.println(&quot;database.getName() = &quot; + database.getName());\n\n        database = Database.getInstance(&quot;두 번째&quot;);\n        System.out.println(&quot;database.getName() = &quot; + database.getName());\n\n        Database d1 = new Database(&quot;1&quot;);\n        Database d2 = new Database(&quot;2&quot;);\n        Database d3 = new Database(&quot;3&quot;);\n        Database d4 = new Database(&quot;4&quot;);\n        Database d5 = new Database(&quot;5&quot;);\n        Database d6 = new Database(&quot;6&quot;);\n\n        System.out.println(&quot;database use&quot;);\n    }\n}</code></pre></div>\n<h2>생성자 문제점과 해결, 쓰레드 사용시 문제점 파악하기</h2>\n<ul>\n<li>생성자를 priavte로 막아 둔다.</li>\n<li>생성을 하기 위해 생성 유틸리티 메서드를 사용한다.</li>\n<li>\n<p>아래의 코드 중 생성자 메서드는 실제 DB 커넥션을 하는 것 처럼 효과를 주기 위함이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Database {\n    private static Database singleton;\n    private String name;\n\n//    public Database(String name) {\n//        super();\n//        this.name = name;\n//    }\n    \n    private Database(String name) {\n        try {\n            Thread.sleep(100);\n            this.name = name;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Database getInstance(String name) {\n        if (singleton == null) {\n            singleton = new Database(name);\n        }\n        return singleton;\n    }\n\n    public String getName() {\n        return name;\n    }\n}</code></pre></div>\n</li>\n</ul>\n<p> Test code 사용 예시</p>\n<ul>\n<li>for 문으로 생성된 객체는 거의 동시에 실행한 효과와 같다. 그렇기 때문에 sigleton 객체는 null로 인식하여 전부 인스턴스를 생성한다.</li>\n<li>생성 순서는 랜덤으로 메모리에 로드되는 순서대로 생성된다.</li>\n<li>\n<p>이 처럼 싱글턴은 스레드에 취약점을 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestPattern2 {\n\n    static int nNUm = 0;\n\n    public static void main(String[] args) {\n        Runnable task = () -&gt; {\n            try {\n                nNUm++;\n                Database database = Database.getInstance(nNUm + &quot;번째 Database&quot;);\n                System.out.println(&quot;This is the &quot; + database.getName());\n\n            } catch (Exception e) {\n                e.getStackTrace();\n            }\n        };\n\n        for (int i = 0; i &lt; 10; i++) {\n            Thread t = new Thread(task);\n            t.start();\n        }\n    }\n}</code></pre></div>\n</li>\n</ul>\n<h2>쓰레드 사용시 문제점 해결 1</h2>\n<ul>\n<li>synchronized 예약어를 사용하여 동기화 처리</li>\n<li>단점: synchronized 는 비용이 비싸다.</li>\n<li>스레드를 한줄로 세워서 순서대로 처리 해야 되기 때문에 병목현상이 일어 한다.</li>\n<li>\n<p>Database 클래스 중 getInstance() 코드 예시</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Database {\n    private static Database singleton;\n    private String name;\n\n    private Database(String name) {\n        try {\n            Thread.sleep(100);\n            this.name = name;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public synchronized static Database getInstance(String name) {\n        if (singleton == null) {\n            singleton = new Database(name);\n        }\n        return singleton;\n    }\n\n    public String getName() {\n        return name;\n    }\n}</code></pre></div>\n</li>\n</ul>\n<h2>쓰레드 사용시 문제점 해결 2</h2>\n<ul>\n<li>Static 키워드는 프로그램이 실행되면 제일 먼저 메모리에 로드 된다는 특성을 가지고 있다.</li>\n<li>\n<p>Static 키워드의 특성을 잘 활용한다. - 생성자 생성 x  직접 생성 o</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Database {\n    private static Database singleton = new Database(&quot;product&quot;);\n    private String name;\n    private Database(String name) {\n        try {\n            Thread.sleep(100);\n            this.name = name;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Database getInstance(String name) {\n         return singleton;\n    }\n\n    public String getName() {\n        return name;\n    }\n}</code></pre></div>\n</li>\n</ul>\n<h2>싱글턴 패턴을 이용한 예제 - 로그 객체</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.time.LocalDateTime;\n\npublic class LogWriter {\n    private static LogWriter singleton = new LogWriter();\n    private static BufferedWriter bw;\n\n    private LogWriter() {\n        try {\n            bw = new BufferedWriter(new FileWriter(&quot;log.txt&quot;));\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    public static LogWriter getInstance() {\n        return singleton;\n    }\n\n    public synchronized void log(String str) {\n        try {\n            bw.write(LocalDateTime.now() + &quot; : &quot; + str + &quot;\\n&quot;);\n            bw.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    protected void finalize() {\n        try {\n            super.finalize();\n            bw.close();\n        } catch (Throwable ex) {\n            ex.printStackTrace();\n        }\n    }\n}</code></pre></div>\n<p> Test code 사용 예시</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestPattern1 {\n    public static void main(String[] args) {\n        LogWriter loggger;\n\n        loggger = LogWriter.getInstance();\n        loggger.log(&quot;홍길동&quot;);\n\n        loggger = LogWriter.getInstance();\n        loggger.log(&quot;전우치&quot;);\n    }\n}\n\n//    웹 상의 많은 페이지를 동시에 열어 본다는 것은 쓰레드에서 동시에 메서드를 호출하는 것과 동일 하다.\npublic class TestPattern2 {\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 50; i++) {\n//            쓰레드 마다 구분되는 로그 작성용 파라미터\n            Thread thread = new ThreadSub(i);\n            thread.start();\n        }\n    }\n}\n\n//    외부 클래스\nclass ThreadSub extends Thread {\n    int num;\n\n    public ThreadSub(int num) {\n        this.num = num;\n    }\n\n    @Override\n    public void run() {\n        LogWriter logger = LogWriter.getInstance();\n        if (num &lt; 10) {\n            logger.log(&quot;*** 0&quot; + num + &quot;***&quot;);\n        } else {\n            logger.log(&quot;*** &quot; + num + &quot;***&quot;);\n\n        }\n    }\n}</code></pre></div>\n<ul>\n<li>TestPattern2 은 실제 여러 스레드가 동시에 접근하더라도 synchronized 예약어를 통해 겹치지 않고 각자 실행이 잘 이루어 진다.</li>\n<li>하지만 실행 순서는 보장되지 않는다. (실행 순서를 확인하기 위해 실행 순서 num 변수 사용)</li>\n</ul>","fields":{"tagSlugs":["/tags/singleton/","/tags/design-pattern/"],"slug":"/design-pattern/singleton/"},"frontmatter":{"title":"Singleton 패턴","tags":["Singleton","design pattern"],"date":"2020-01-02T05:06:35.750Z","description":"객체가 너무 많아지면 컴퓨터 자원을 과도하게 사용하게 되고, 이는 프로그램 전체의 속도를 느리게 할 수 있다. → 개발자는 객체의 최대 개수를 제한할 필요가 생긴다.","path":"/design-pattern/singleton/","category":"design-pattern"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/design-pattern/singleton/#%EC%8B%B1%EA%B8%80%ED%84%B4-%ED%8C%A8%ED%84%B4\">싱글턴 패턴</a></p>\n<ul>\n<li>\n<p><a href=\"/design-pattern/singleton/#%EC%82%AC%EC%9A%A9-%EC%98%88\">사용 예</a></p>\n<ul>\n<li><a href=\"/design-pattern/singleton/#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EA%B0%9C%EC%88%98-%EC%A0%9C%ED%95%9C-%ED%95%98%EA%B8%B0\">객체 생성 개수 제한 하기</a></li>\n</ul>\n</li>\n<li><a href=\"/design-pattern/singleton/#%EC%83%9D%EC%84%B1%EC%9E%90-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0\">생성자 문제점과 해결, 쓰레드 사용시 문제점 파악하기</a></li>\n<li><a href=\"/design-pattern/singleton/#%EC%93%B0%EB%A0%88%EB%93%9C-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90-%ED%95%B4%EA%B2%B0-1\">쓰레드 사용시 문제점 해결 1</a></li>\n<li><a href=\"/design-pattern/singleton/#%EC%93%B0%EB%A0%88%EB%93%9C-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90-%ED%95%B4%EA%B2%B0-2\">쓰레드 사용시 문제점 해결 2</a></li>\n<li><a href=\"/design-pattern/singleton/#%EC%8B%B1%EA%B8%80%ED%84%B4-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%98%88%EC%A0%9C---%EB%A1%9C%EA%B7%B8-%EA%B0%9D%EC%B2%B4\">싱글턴 패턴을 이용한 예제 - 로그 객체</a></li>\n</ul>\n</li>\n</ul>","headings":[{"value":"싱글턴 패턴","depth":1},{"value":"사용 예","depth":2},{"value":"객체 생성 개수 제한 하기","depth":3},{"value":"생성자 문제점과 해결, 쓰레드 사용시 문제점 파악하기","depth":2},{"value":"쓰레드 사용시 문제점 해결 1","depth":2},{"value":"쓰레드 사용시 문제점 해결 2","depth":2},{"value":"싱글턴 패턴을 이용한 예제 - 로그 객체","depth":2}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/design-pattern/singleton/"}}}