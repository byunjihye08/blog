{"componentChunkName":"component---src-templates-post-template-jsx","path":"/cs/data-structure/trie","result":{"data":{"site":{"siteMetadata":{"title":"변지혜 블로그","subtitle":"행동하는 개발자","copyright":"© All rights reserved.","author":{"name":"변지혜","twitter":"#"},"disqusShortname":"regyu","url":"https://wisdom08.netlify.com/"}},"markdownRemark":{"id":"c9a6703b-5090-5bc5-89c1-78c12c554664","html":"<h1>Trie 구조 (문자열 검색)</h1>\n<p>Tags: tree, trie, 문자열</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/372cbeefae10ffcbb5505abd588e1f3e/288d3/Untitled.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 960px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 100.28368794326241%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAADW0lEQVQ4y4VUe2iOYRQ/5/3GQiajpJTcleWy3P5wCf9I2+Su5BIlxayIXNJCckmGSG2SKCuzy/cxdmM2s82mrbmkhH80pDYNxfi+5+ec93m/b++3wltP73nOc57f+Z3z/J6H+LYB6bgDqM2eTZ7N6o+OXnFxcy+GYpu9f9Rmvx0N7hXnn8diuLezVOxQGByK2MzBsP2Lj4K/PL+Mu/FJYjh202/QA3FmXQGn7QCLTWUekyr5y2aqkPUa+VfCjec5q8Ena0H3YZPFMVQWurDnBnj1AfCpOvDFF5bJoSA4vwOc0wTStUuvZP2R9IpAaZkuU3+/XUAqkVJqZbJiD2j8TNDoaaB0CS76AeqTCF62CzRwiPXPXQNed9gF5CmLwLe+gUphk8cBPpLJ0izQyBTQhNmglfts9v6DwOuPCthUUMp88P4CcIGADEwG774Ofigx2gJ/yTGGGVnuRmf8DATmrwVfeGaZZOaBj1WBFm208+PVoKShoMxc2++S7p7Tdw111MNl5YybDtpy1t3oDB4GFobOphPg0VPAw8eAxqbCyX0tc2G8Nx9cJ/vKVRn+kpWuOBwJplGpmNcKLLlWDzrXBrr8DlTcDbraDjpQBKegS0oMu9Xw+VbwmSZw9m1whQUlBVKJcN4bJMxKAx2uRqgDaPtpM/cTmfS/BwwVFfTVfomdWPQdSenbQDnNoDmr3L6rSlS/FBVlwNNaaiPQ2R3B1+4wsl+F0fIlgiedERS0hxH6IHot/IXiLuB0fkhadAiB5OEgJ8H2uFKvnk/pjmYoCaPss8HjDoP0JgPAYPtzg4UNBuGIwfLmCH6IN2PWZNDWS+7h0chJguFdR/9j0LdU7FsG194bhD4ZzK4z+PrbILlc/MUG9R0RdEmO1vYvcAYkgbJLwRk7QZPm2sMRtVDP5Tfoo/e40CAoYLXCcEGDZTihWgALgQ0tEeh38GmnlMZI2H/TSkl7WGP1GAcYcCVkkCGlrnpqMKLKYNdLYVimDIHFjcYFnFghN2hzDgIqnyPlVuCxU449TbZsR+2gAmsAXCDXJyXnvDUo/mjcdUfvvpw4ixJYDyN29XwMo2oP3LFDfQk+f9I9bYv3DqoWtf/KSp87/03511DmPcl65n5/XPz/AP3M2WP9NzAdfwBUpfflOgnLmQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Trie/Untitled.png\"\n        title=\"\"\n        src=\"/static/372cbeefae10ffcbb5505abd588e1f3e/f570d/Untitled.png\"\n        srcset=\"/static/372cbeefae10ffcbb5505abd588e1f3e/0783d/Untitled.png 240w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/782f4/Untitled.png 480w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/f570d/Untitled.png 960w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/8d0ff/Untitled.png 1440w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/a987b/Untitled.png 1920w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/288d3/Untitled.png 2115w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2>TMI</h2>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/60060\">코딩테스트 연습 - 가사 검색 | 프로그래머스</a></p>\n<p>오늘도 여김 없이 TMI부터 시작한다. 코딩 테스트 연습을 하면서 알게 된 Trie (트라이) 라는 자료 구조에 대헤 정리 한다. </p>\n<h2>Trie-트라이</h2>\n<blockquote>\n<p>문자열을 효율적으로 탐색하기 위한 자료 구조로 n 진 Tree(트리)형태로 구성되어 있다.</p>\n</blockquote>\n<p>트라이?? 발음은 Try 랑 같다. 잘 모르겠지만 일단 Try 해보자!!</p>\n<p>우리가 여러 개의 문자열을 가지고 있을 때, 어떤 문자열이 그 문자열 중 하나인지 알아내는 방법은 뭐가 있을까?단순하게 일일이 비교해보면 된다. 하지만 컴퓨터는 이러한 방법이 매우 비효율적이다. 예를 들어, 최대 길이가</p>\n<p>m인 문자열 <em>n</em>개의 집합에서 마찬가지로 최대 길이가<em>m</em>인 임의의 문자열이 그 문자열들의 집합에 포함되는지를 일일이 확인하면 사전처리는 필요 없지만, 최악의 경우O(nm)의 비교 횟수가 필요하다.</p>\n<p>이 문자열을 정렬시킨 뒤, <a href=\"https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89\">이진 탐색</a> 이라는 강력한 알고리즘을 사용하면O(m log n)로 단축시킬 수 있지만, 정렬 과정 자체에 O(n m log n)의 시간이 걸리므로 사양이 안 좋은 컴퓨터라면 이것도 비효율적이다. 하지만 위의 시간 복잡도를 압도하는 알고리즘이 존재한다. 프레드킨이 이름 붙인 “Trie”라는 자료구조가 지금부터 설명할 가장 효율적인 문자열 검색법이다.</p>\n<h2>구현 코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TrieNode {\n    private final Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();\n    private boolean endOfWord;\n    private int count;\n\n    Map&lt;Character, TrieNode&gt; getChildren() {\n        return children;\n    }\n\n    boolean isEndOfWord() {\n        return endOfWord;\n    }\n\n    void setEndOfWord(boolean endOfWord) {\n        this.endOfWord = endOfWord;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    void increaseCount() {\n        this.count++;\n    }\n}\n\npublic class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word)1\n        TrieNode current = root;\n\n        current.increaseCount();\n        current = current.getChildren()\n                .computeIfAbsent((char) (word.length() + &#39;0&#39;), c -&gt; new TrieNode());\n\n        for (char trieWord : word.toCharArray()) {\n            current.increaseCount();\n            current = current.getChildren()\n                    .computeIfAbsent(trieWord, c -&gt; new TrieNode());\n        }\n\n        current.setEndOfWord(true);\n    }\n\n    public int countOfSearched(String word, int index) {\n        TrieNode current = root;\n\n        TrieNode wordLengthNode = current.getChildren().get((char) (word.length() + &#39;0&#39;));\n        if (wordLengthNode == null) {\n            return 0;\n        }\n        current = wordLengthNode;\n\n        for (int i = 0; i &lt; index; i++) {\n            char ch = word.charAt(i);\n            TrieNode node = current.getChildren().get(ch);\n            if (node == null) {\n                return 0;\n            }\n            current = node;\n        }\n        return current.getCount();\n    }\n}</code></pre></div>\n<h2>update 예정…</h2>","fields":{"tagSlugs":["/tags//"],"slug":"/cs/data-structure/trie"},"frontmatter":{"title":"Trie 트라이","tags":[""],"date":"2019-11-14T05:06:35.750Z","description":"코딩 테스트 연습을 하면서 알게 된 Trie (트라이) 라는 자료 구조에 대헤 정리 한다.","path":"/cs/data-structure/trie","category":"data-structure"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/cs/data-structure/trie/#trie-%EA%B5%AC%EC%A1%B0-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89\">Trie 구조 (문자열 검색)</a></p>\n<ul>\n<li><a href=\"/cs/data-structure/trie/#tmi\">TMI</a></li>\n<li><a href=\"/cs/data-structure/trie/#trie-%ED%8A%B8%EB%9D%BC%EC%9D%B4\">Trie-트라이</a></li>\n<li><a href=\"/cs/data-structure/trie/#%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C\">구현 코드</a></li>\n<li><a href=\"/cs/data-structure/trie/#update-%EC%98%88%EC%A0%95\">update 예정…</a></li>\n</ul>\n</li>\n</ul>","headings":[{"value":"Trie 구조 (문자열 검색)","depth":1},{"value":"TMI","depth":2},{"value":"Trie-트라이","depth":2},{"value":"구현 코드","depth":2},{"value":"update 예정…","depth":2}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/cs/data-structure/trie"}}}