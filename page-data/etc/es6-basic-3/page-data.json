{"componentChunkName":"component---src-templates-post-template-jsx","path":"/etc/es6-basic-3/","result":{"data":{"site":{"siteMetadata":{"title":"변지혜 블로그","subtitle":"행동하는 개발자","copyright":"© All rights reserved.","author":{"name":"변지혜","twitter":"#"},"disqusShortname":"regyu","url":"https://wisdom08.netlify.com/"}},"markdownRemark":{"id":"3f30933e-8938-5969-8195-14a3476dc0a8","html":"<h1>es6 basic 3</h1>\n<p><a href=\"https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA\">코드스피츠</a></p>\n<p>채널에서 보고 정리한 글입니다.</p>\n<hr>\n<p><a href=\"https://wonism.github.io/javascript-iteration-protocol/\">WONISM’s Blog</a> 블로그 참고</p>\n<p>Iterables vs Iterator</p>\n<ul>\n<li>iterable 프로토콜은 반복 가능한 <strong>객체를</strong> 나타내는 프로토콜</li>\n<li>iterator 프로토콜은 반복 가능한 <strong>객체의 값</strong>을 시퀸스대로 처리하는 프로토콜</li>\n</ul>\n<h2>Interface in JS</h2>\n<ol>\n<li>인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트</li>\n<li>어떤 Object라도 인터페이스의 정의를 충족시킬 수 있다.</li>\n<li>하나의 Object는 여러개의 인터페이스를 충족시킬 수 있다.</li>\n</ol>\n<h3>Interface Test</h3>\n<ol>\n<li>test라는 키를 갖고</li>\n<li>\n<p>값으로 문자열인자를 1개 받아 불린결과를 반환하는 함수가 온다.</p>\n<p>{\ntest(str){return true;}\n}</p>\n</li>\n</ol>\n<h2>Iterator Interface</h2>\n<ol>\n<li>next라는 키를 갖고</li>\n<li>값으로 인자를 받지 않고 IteratorResultObject를 반환하는 함수가 온다.</li>\n<li>IteratorResultObject는 value와 done이라는 키를 갖고 있다.</li>\n<li>\n<p>이중done은계속반복할수있을지없을지에따라불린값을반환한다.</p>\n<p>{\nnext(){\nreturn {value:1, done:false}; }\n}</p>\n<p>{\ndata:[1,2,3,4],\nnext(){\nreturn {\ndone:this.data.length == 0,\nvalue:this.data.pop()\n};\n}\n}</p>\n</li>\n</ol>\n<h2>Iterable Interface</h2>\n<ol>\n<li>Symbol.iterator라는 키를 갖고</li>\n<li>\n<p>값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.</p>\n<p>{\n<a href=\"\">Symbol.iterator</a>{\nreturn {\nnext(){\nreturn {value:1, done:false};\n}\n};\n}\n}</p>\n</li>\n</ol>\n<h2>Loop to iterator</h2>\n<p>statement(문) : 엔진한테 주는 힌트 , 실행하고 나면 흔적도 없이 사라진다.</p>\n<p>expression(식): 메모리에 남고, 언제든지 조회, 참조 할 수 있다.</p>\n<p>for, while 은 문이다.</p>\n<p>iterator 는 loop 를 식으로 바꾸고 싶어서 사용한다.</p>\n<h2>while문으로 살펴보는 Iterator</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let arr = [1, 2, 3, 4];\nwhile(arr.length &gt; 0){ //계속 반복할지 판단\n\tconsole.log(arr.pop()); //반복시 처리할 것\n}\n// 4 \n// 3 \n// 2 \n// 1</code></pre></div>\n<p>Iterator Interface</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n\tarr:[1, 2, 3, 4], \n\tnext(){\n\t\treturn {\n//self descrition\n//계속 반복할지 판단\n\t\tdone:this.arr.length == 0,  \n//반복시 처리할 것\n\t\tvalue:console.log(this.arr.pop())\n\t\t}; \n\t}\n}</code></pre></div>\n<ol>\n<li>반복자체를 하지는 않지만</li>\n<li>외부에서반복을하려고할때</li>\n<li>반복에 필요한 조건과 실행을</li>\n<li>미리준비해둔객체</li>\n</ol>\n<p>→</p>\n<p>반복행위와 반복을 위한 준비를 분리</p>\n<p>→</p>\n<ol>\n<li>미리반복에대한준비를해두고</li>\n<li>필요할 때 필요한만큼 반복</li>\n<li>반복을재현할수있음</li>\n</ol>\n<h2>es6+ Loop</h2>\n<ul>\n<li>\n<p>사용자반복처리기직접 Iterator 반복처리기를 구현</p>\n<p>const loop = (iter, f) => {\n//Iterable이라면 Iterator를 얻음\nif(typeof iter[Symbol.iterator] == ‘function’){\niter = iter<a href=\"\">Symbol.iterator</a>;\n}\n//IteratorObject가 아니라면 건너뜀\nif(typeof iter.next != ‘function’) return;\ndo{\nconst v = iter.next(); if(v.done) return; //종료처리 f(v.value); //현재 값을 전달함\n}while(true);\n};</p>\n<p>const iter = {\narr:[1, 2, 3, 4],\n<a href=\"\">Symbol.iterator</a>{return this;}, next(){\nreturn {\ndone:this.arr.length == 0,\nvalue:this.arr.pop()\n};\nloop(iter, console.log);\n//4\n//3\n//2\n//1</p>\n</li>\n<li>내장반복처리기</li>\n</ul>\n<p>Array destructuring (배열해체)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const iter = {\n  [Symbol.iterator]() {\n    return this;\n  },\n  arr: [1, 2, 3, 4],\n  next() {\n    return { done: this.arr.length == 0, value: this.arr.pop() };\n  }\n};\n\nconst [a, ...b] = iter;\nconsole.log(a, b);\n// 4, [3, 2, 1]</code></pre></div>\n<p>Spread (펼치기)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const iter = {\n  [Symbol.iterator]() {\n    return this;\n  },\n  arr: [1, 2, 3, 4],\n  next() {\n    return { done: this.arr.length == 0, value: this.arr.pop() };\n  }\n};\nconst a = [...iter];\nconsole.log(a);\n// [4, 3, 2, 1]</code></pre></div>\n<p>Rest Parameter (나머지인자)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const iter = {\n  [Symbol.iterator]() {\n    return this;\n  },\n  arr: [1, 2, 3, 4],\n  next() {\n    return { done: this.arr.length == 0, value: this.arr.pop() };\n  }\n};\nconst test = (...arg) =&gt; console.log(arg);\ntest(...iter);\n// [4, 3, 2, 1]</code></pre></div>\n<p>For of (문 - 권한이 거의 없는 문)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const iter = {\n  [Symbol.iterator]() {\n    return this;\n  },\n  arr: [1, 2, 3, 4],\n  next() {\n    return { done: this.arr.length == 0, value: this.arr.pop() };\n  }\n};\nfor (const v of iter) {\n  console.log(v);\n}\n//4 //3 //2 //1</code></pre></div>\n<hr>\n<h2>블로킹(Blocking)</h2>\n<p>프로그램은 노이만 머신(메모리)에 적재되면 쉴 틈 없이 실행되고, 우리는 간섭하지 못한다. </p>\n<p>이러한 상태를 동기 명령이라고 한다. 동기 명령이란 한번 적재된 명령어를 한번에 쭉 실행되는 것을 말한다.  </p>\n<p>동기 명령어가 실행되는 것을  관찰하는 것이 flow 이다. </p>\n<p>동기 명령어가 실행되고 있을 때에는 cpu를 건들 일 수 없다. cpu 를 못 건들 이는 현상을 block(blocking)이라고 한다.</p>\n<p>블로킹을 걸 수 있는 범위는 5초 이내이다.</p>\n<p>시간 동안 얼만큼 많은 일을 할 수 있는 지는 cpu 클럭 수, 비트 수에 달려 있다.</p>\n<p>loop 가 길면 블로킹으로 걸면 안된다.(os, 브라우저 가 실행을 종료 해버린다.) Generator cpu 를 sleep을 걸어 주어 release 하여 다른 작업을 할 수 있게 해야 한다.</p>\n<p> node 에서는 nexttick() 브라우저에서는 request animation frame 이나 setTimeout() 이 있다.</p>\n<p>무한 루프가 없도록 limit 를 걸어 줘야 한다.</p>\n<p>Iterator 를 만들때 done 의 limit 를 설정해줘야 한다.</p>\n<p>ex) next() {\nif (cursor > max) </p>\n<p>}</p>\n<hr>\n<h2>practice</h2>\n<p>제곱을 요소로 갖는 가상컬렉션</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const N2 = class {\n  constructor(max) {\n    this.max = max;\n  }\n  [Symbol.iterator]() {\n    let cursor = 0,\n      max = this.max;\n    return {\n      done: false,\n      next() {\n//함수는 함수 바깥쪽의 변수를 캡쳐할 수 있는 권한이 있다. 이를 free value (자유변수)라고 한다.\n//자유 변수가 갇히(가두)면 클로져라고 한다.\n        if (cursor &gt; max) {\n          this.done = true;\n        } else {\n          this.value = cursor * cursor;\n          cursor++;\n        }\n        return this;\n      }\n    };\n  }\n};\n\nconsole.log([...new N2(5)]);\n//[0, 1, 4, 9, 16]\n\nfor (const v of new N2(5)) {\n  console.log(v);\n}\n// 0\n// 1\n// 4\n// 9\n// 16</code></pre></div>\n<h2>Generator</h2>\n<p><a href=\"https://medium.com/@jooyunghan/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9E%AC%EB%AF%B8-246553cadfbd\">자바스크립트 제너레이터의 재미</a> 블로그 참고</p>\n<p>Iterator의 구현을 돕는 Generator</p>\n<p>Generator 는 호출 할때 마다 iterator 가 만들어 진다.</p>\n<p>Generator가 만드는 <strong>iterator 는 동시에 Iterable</strong> 이기도 한다.</p>\n<p>Generator는 yield 이때 잠깐 suspension 이 생겨  coroutine 이라고도 한다. 일반적인 함수는 은 routine 이라고 한다.</p>\n<p>(iterator 는 동시에 Iterable 이기에 for of 를 이용 할 수 있다.)</p>\n<p>(for of 는 Generator를 사용 할 수 없다.)</p>\n<p>배열은 for of 로 돌아간다. === 배열 === Iterable, Symbol.iterator를 호출 하면 배열이 나온다. === 배열 ===iterator</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const N2 = class {\n  constructor(max) {\n    this.max = max;\n  }\n  [Symbol.iterator]() {\n    let cursor = 0,\n      max = this.max;\n    return {\n      done: false,\n      next() {\n        if (cursor &gt; max) {\n          this.done = true;\n        } else {\n          this.value = cursor * cursor;\n          cursor++;\n        }\n        return this;\n      }\n    };\n  }\n};\n\nconst generator = function*(max) {\n  let cursor = 0;\n  while (cursor &lt; max) {\n    yield cursor * cursor;\n//yield 이때 잠깐 suspension 이 생겨 \n//iterator result object 를 반환해준다. \n    cursor++;\n  }\n};\nconsole.log([...generator(5)]);\n//[0, 1, 4, 9, 16]\nfor (const v of generator(5)) {\n  console.log(v);\n}\n//0 \n//1 \n//4 \n//9 \n//16</code></pre></div>","fields":{"tagSlugs":["/tags/iterator/","/tags/iterable/","/tags/interface/","/tags/generator/"],"slug":"/etc/es6-basic-3/"},"frontmatter":{"title":"ES6 Basic 3","tags":["Iterator","Iterable","Interface","Generator"],"date":"2019-04-25T05:45:35.750Z","description":"Code spitz에서 강의한 ES6 기초, 루프구조에 대해 보다 깊이 탐험해봅니다. 또한 Iterator과 Iterable의 관계, Generator에 대해 알아봅시다.","path":"/etc/es6-basic-3/","category":"js"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/etc/es6-basic-3/#es6-basic-3\">es6 basic 3</a></p>\n<ul>\n<li>\n<p><a href=\"/etc/es6-basic-3/#interface-in-js\">Interface in JS</a></p>\n<ul>\n<li><a href=\"/etc/es6-basic-3/#interface-test\">Interface Test</a></li>\n</ul>\n</li>\n<li><a href=\"/etc/es6-basic-3/#iterator-interface\">Iterator Interface</a></li>\n<li><a href=\"/etc/es6-basic-3/#iterable-interface\">Iterable Interface</a></li>\n<li><a href=\"/etc/es6-basic-3/#loop-to-iterator\">Loop to iterator</a></li>\n<li><a href=\"/etc/es6-basic-3/#while%EB%AC%B8%EC%9C%BC%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-iterator\">while문으로 살펴보는 Iterator</a></li>\n<li><a href=\"/etc/es6-basic-3/#es6-loop\">es6+ Loop</a></li>\n<li><a href=\"/etc/es6-basic-3/#%EB%B8%94%EB%A1%9C%ED%82%B9blocking\">블로킹(Blocking)</a></li>\n<li><a href=\"/etc/es6-basic-3/#practice\">practice</a></li>\n<li><a href=\"/etc/es6-basic-3/#generator\">Generator</a></li>\n</ul>\n</li>\n</ul>","headings":[{"value":"es6 basic 3","depth":1},{"value":"Interface in JS","depth":2},{"value":"Interface Test","depth":3},{"value":"Iterator Interface","depth":2},{"value":"Iterable Interface","depth":2},{"value":"Loop to iterator","depth":2},{"value":"while문으로 살펴보는 Iterator","depth":2},{"value":"es6+ Loop","depth":2},{"value":"블로킹(Blocking)","depth":2},{"value":"practice","depth":2},{"value":"Generator","depth":2}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/etc/es6-basic-3/"}}}